(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{432:function(e,t,n){"use strict";n.r(t);var o=n(65),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"数据类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[e._v("#")]),e._v(" 数据类型")]),e._v(" "),n("p",[e._v("最新的 ECMAScript 标准定义了 8 种数据类型:")]),e._v(" "),n("p",[e._v('7 种原始类型，使用 typeof 运算符检查:\nundefined：typeof instance === "undefined"\nBoolean：typeof instance === "boolean"\nNumber：typeof instance === "number"\nString：typeof instance === "string\nBigInt：typeof instance === "bigint"\nSymbol ：typeof instance === "symbol"\nnull：typeof instance === "object"。\nObject：typeof instance === "object"。任何 constructed 对象实例的特殊非数据结构类型，也用做数据结构：new Object，new Array，new Map，new Set，new WeakMap，new WeakSet，new Date，和几乎所有通过 new keyword 创建的东西。\n记住 typeof 操作符的唯一目的就是检查数据类型，如果我们希望检查任何从 Object 派生出来的结构类型，使用 typeof 是不起作用的，因为总是会得到 "object"。检查 Object 种类的合适方式是使用 instanceof 关键字。但即使这样也存在误差。')]),e._v(" "),n("p",[e._v("typeof 返回类型 object number string function undefined boolean\ntypeof  null  返回 object")]),e._v(" "),n("p",[e._v("基本类型 存在栈中，引用类型存在栈和堆中。")]),e._v(" "),n("h3",{attrs:{id:"类型判断"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类型判断"}},[e._v("#")]),e._v(" 类型判断")]),e._v(" "),n("ol",[n("li",[e._v("typeof。 判断出基本类型 和Object")]),e._v(" "),n("li",[e._v("instanceof 。判断对象的类型。原理通过原型链。")]),e._v(" "),n("li",[e._v("Object.prototype.toString.call()")])])])}),[],!1,null,null,null);t.default=a.exports}}]);