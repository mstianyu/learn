(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{436:function(t,n,a){"use strict";a.r(n);var v=a(65),_=Object(v.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"一切皆对象。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一切皆对象。"}},[t._v("#")]),t._v(" 一切皆对象。")]),t._v(" "),a("p",[t._v("JavaScript的世界中的对象，追根溯源来自于一个 null。佛曰：万物皆空")]),t._v(" "),a("p",[t._v("万物初生时，一个null对象，凭空而生，接着Object、Function学着null的模样塑造了自己，并且它们彼此之间喜结连理，提供了prototype和constructor，一个给子孙提供了基因，一个则制造万千子子孙孙。")]),t._v(" "),a("p",[t._v("JavaScript中，null也是作为一个对象存在，基于它继承的子子孙孙，当属对象。\n乍一看，null像是上帝,而Object和Function犹如JavaScript世界中的亚当与夏娃。")]),t._v(" "),a("h3",{attrs:{id:"关于竟争力"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于竟争力"}},[t._v("#")]),t._v(" 关于竟争力")]),t._v(" "),a("ol",[a("li",[t._v("学习一件事物，熟练使用它是基本，在熟练使用以后，应该转而去学习他底层的原理机制，甚至自己去实现一个类似的东西。当你这样去做的时候，永远不需要担心自己是否会淘汰，因为你已经领先所有只会用 API 的人。")]),t._v(" "),a("li",[t._v("具体\n● 夯实自己的基础，基础决定了大楼的高度\n● 有深入挖掘知识的思想，对于每个知识点都应该考虑一下这玩意怎么实现的，为什么要  有这玩意\n● 不要做框架 API 的熟练工，尽量去了解框架底层的原理机制。")])]),t._v(" "),a("h3",{attrs:{id:"关于学习"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于学习"}},[t._v("#")]),t._v(" 关于学习")]),t._v(" "),a("ol",[a("li",[t._v("计算机科学基础。越核心的东西、更新的频率越低，这是每个技术人的内功。像张无忌一样，内功越强，杂七杂八的武功可不都是信手拈来？")]),t._v(" "),a("li",[t._v("沉淀下来的东西。")]),t._v(" "),a("li",[t._v("不管什么时候，新技术往往是成群出现的、屡见不鲜。比如之前各种各样的 CSS-in-js 库、各种状态管理库、各种跨平台小程序框架、视图框架...")]),t._v(" "),a("li",[t._v("真的是你需要的吗？如果不是要解决你的燃眉之急，尚且先慢下来等待他们自行洗牌，最后能活下来的才是你应该学习的。")]),t._v(" "),a("li",[t._v("更进一步的是形成属于自己知识体系，对知识进行归纳和内化、找出知识之间的关联。当分散的点联系成了网络，等待下一步质变。")])]),t._v(" "),a("h3",{attrs:{id:"关于面试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于面试"}},[t._v("#")]),t._v(" 关于面试")]),t._v(" "),a("ol",[a("li",[t._v("技术层面。\n● 基础考察\n● 原理考察\n● 项目考察")]),t._v(" "),a("li",[t._v("综合层面\n● 考察综合素质\n● 考察技能使用\n● 考察沟通能力\n● 考察性格\n● 考察做过的项目\n● 工作年限\n● 离职原因\n● 工作态度")])]),t._v(" "),a("h3",{attrs:{id:"软件开发原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件开发原则"}},[t._v("#")]),t._v(" 软件开发原则")]),t._v(" "),a("p",[t._v("常用主要有以下几种\n✓ 单一职责原则 重点\n✓ 最少知识原则\n✓ 里氏替换原则\n✓ 依赖倒置原则\n✓ 接口隔离原则\n✓ 合成复用原则\n✓ 开放封闭原则（用抽象构建框架，用实现扩展细节） 重点")]),t._v(" "),a("p",[t._v("一个软件实体应当对扩展开放(open)，则修改关闭(不修改原来的代码这就是closed)。在设计一个模块时，应当使得这个模块可以在不被修改的前提下被扩展(这就要求我们不能在一个类中写死所有的功能)。也就是说，应当可以在不必修改源代码的情况下修改这个模块的行为。")]),t._v(" "),a("h3",{attrs:{id:"代码设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码设计模式"}},[t._v("#")]),t._v(" 代码设计模式")]),t._v(" "),a("p",[t._v("✓   订阅发布\n✓   观察者模\n✓   策略模式\n✓   单列模式\n✓   装饰者模式\n✓   代理模式")])])}),[],!1,null,null,null);n.default=_.exports}}]);